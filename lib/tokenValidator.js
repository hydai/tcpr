/**
 * Shared token validation logic
 */

import axios from 'axios';
import { TWITCH_URLS, REQUIRED_SCOPES } from '../config/constants.js';
import { TokenValidationError, TokenOwnershipError, TokenScopeError } from './errors.js';

/**
 * Token validator class with shared validation logic
 */
export class TokenValidator {
  /**
   * Validate a Twitch access token
   *
   * This method performs comprehensive validation:
   * 1. Verifies the token is valid via Twitch API
   * 2. Ensures the token belongs to the specified broadcaster (fails if mismatch)
   * 3. Confirms the token has at least one required scope
   *
   * @param {string} accessToken - The access token to validate
   * @param {string} broadcasterId - Broadcaster user ID that MUST own this token
   * @returns {Promise<Object>} Token validation data from Twitch API
   * @throws {TokenOwnershipError} If token belongs to different user than broadcasterId
   * @throws {TokenScopeError} If token lacks required scopes
   * @throws {TokenValidationError} If token is invalid, expired, or API call fails
   */
  static async validate(accessToken, broadcasterId) {
    try {
      // Validate the token via Twitch API
      const response = await axios.get(TWITCH_URLS.OAUTH_VALIDATE, {
        headers: {
          'Authorization': `OAuth ${accessToken}`
        }
      });

      const tokenData = response.data;

      // Check if token belongs to the broadcaster
      if (tokenData.user_id !== broadcasterId) {
        throw new TokenOwnershipError(tokenData.user_id, broadcasterId);
      }

      // Check for required scopes
      const hasRequiredScope = REQUIRED_SCOPES.some(scope =>
        tokenData.scopes.includes(scope)
      );

      if (!hasRequiredScope) {
        throw new TokenScopeError(tokenData.scopes, REQUIRED_SCOPES);
      }

      return tokenData;
    } catch (error) {
      // Re-throw our custom errors
      if (error instanceof TokenValidationError) {
        throw error;
      }

      // Handle HTTP errors
      if (error.response) {
        if (error.response.status === 401) {
          throw new TokenValidationError(
            'Invalid or expired access token',
            'invalid_token',
            { statusCode: 401 }
          );
        }

        throw new TokenValidationError(
          `Token validation failed: ${error.message}`,
          'api_error',
          { statusCode: error.response.status, data: error.response.data }
        );
      }

      // Handle network errors
      throw new TokenValidationError(
        `Token validation error: ${error.message}`,
        'network_error',
        { originalError: error }
      );
    }
  }

  /**
   * Validate token without throwing (returns result object)
   *
   * @param {string} accessToken - The access token to validate
   * @param {string} broadcasterId - Broadcaster user ID that MUST own this token
   * @returns {Promise<Object>} Validation result with success flag and data/error
   */
  static async validateSafe(accessToken, broadcasterId) {
    try {
      const tokenData = await TokenValidator.validate(accessToken, broadcasterId);
      return {
        success: true,
        data: tokenData
      };
    } catch (error) {
      return {
        success: false,
        error: error
      };
    }
  }

  /**
   * Quick check if token is valid (just checks with Twitch API)
   * @param {string} accessToken - The access token to check
   * @returns {Promise<Object|null>} Token data if valid, null if invalid
   */
  static async quickCheck(accessToken) {
    try {
      const response = await axios.get(TWITCH_URLS.OAUTH_VALIDATE, {
        headers: {
          'Authorization': `OAuth ${accessToken}`
        }
      });

      return response.data;
    } catch (error) {
      return null;
    }
  }

  /**
   * Check if token has specific scope
   * @param {string[]} tokenScopes - Array of scopes from token
   * @param {string} requiredScope - Required scope to check
   * @returns {boolean} True if token has the scope
   */
  static hasScope(tokenScopes, requiredScope) {
    return tokenScopes.includes(requiredScope);
  }

  /**
   * Check if token has any of the required scopes
   * @param {string[]} tokenScopes - Array of scopes from token
   * @param {string[]} requiredScopes - Array of required scopes (needs at least one)
   * @returns {boolean} True if token has at least one required scope
   */
  static hasAnyScope(tokenScopes, requiredScopes) {
    return requiredScopes.some(scope => tokenScopes.includes(scope));
  }

  /**
   * Format validation error for user display
   * @param {TokenValidationError} error - The validation error
   * @returns {Object} Formatted error info with message and solution
   */
  static formatError(error) {
    if (error instanceof TokenOwnershipError) {
      return {
        message: error.message,
        solution: [
          'The access token MUST be generated by the broadcaster account.',
          'Either:',
          '1. Generate a new token using the broadcaster account, OR',
          `2. Update TWITCH_BROADCASTER_ID to ${error.tokenUserId}`
        ]
      };
    }

    if (error instanceof TokenScopeError) {
      return {
        message: error.message,
        solution: [
          'Generate a new access token with one of the required scopes:',
          '- Using OAuth server: npm run oauth',
          '- Using Twitch CLI: twitch token -u -s channel:read:redemptions',
          '- Or use the OAuth URL in the README with the correct scope'
        ]
      };
    }

    if (error.reason === 'invalid_token') {
      return {
        message: 'Invalid or expired access token',
        solution: [
          'Generate a new access token:',
          '- Using OAuth server: npm run oauth',
          '- Using Twitch CLI: twitch token -u -s channel:read:redemptions',
          '- Or use the token generator in the README'
        ]
      };
    }

    return {
      message: error.message,
      solution: ['Check your configuration and try again']
    };
  }
}

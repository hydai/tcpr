import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import { fork } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let mainWindow;
let eventSubProcess = null;
let oauthServerProcess = null;

// Path to .env file
const envPath = path.join(app.getPath('userData'), '.env');

// Create main window
function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    icon: path.join(__dirname, '../build/icon.png'),
    backgroundColor: '#0e0e10',
    show: false
  });

  // Load the GUI
  mainWindow.loadFile(path.join(__dirname, '../gui/index.html'));

  // Show window when ready
  mainWindow.once('ready-to-show', () => {
    mainWindow.show();
  });

  // Open DevTools in development
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on('closed', () => {
    mainWindow = null;
    stopEventSub();
    stopOAuthServer();
  });
}

// App ready
app.whenReady().then(() => {
  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

// Quit when all windows are closed
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// IPC Handlers

// Helper function to load configuration
async function loadConfig() {
  try {
    if (fs.existsSync(envPath)) {
      const content = fs.readFileSync(envPath, 'utf-8');
      const config = {};

      content.split('\n').forEach(line => {
        line = line.trim();
        if (line && !line.startsWith('#')) {
          const [key, ...valueParts] = line.split('=');
          const value = valueParts.join('=').trim();
          config[key.trim()] = value;
        }
      });

      return { success: true, config };
    }
    return { success: true, config: {} };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// Load configuration
ipcMain.handle('config:load', loadConfig);

// Save configuration
ipcMain.handle('config:save', async (event, config) => {
  try {
    // Ensure user data directory exists
    const userDataDir = app.getPath('userData');
    if (!fs.existsSync(userDataDir)) {
      fs.mkdirSync(userDataDir, { recursive: true });
    }

    const lines = [
      '# Twitch Channel Points Monitor Configuration',
      '# Generated by the GUI application',
      '',
      `TWITCH_CLIENT_ID=${config.TWITCH_CLIENT_ID || ''}`,
      `TWITCH_CLIENT_SECRET=${config.TWITCH_CLIENT_SECRET || ''}`,
      `TWITCH_ACCESS_TOKEN=${config.TWITCH_ACCESS_TOKEN || ''}`,
      `TWITCH_BROADCASTER_ID=${config.TWITCH_BROADCASTER_ID || ''}`,
      `REDIRECT_URI=${config.REDIRECT_URI || 'http://localhost:3000/callback'}`,
      `PORT=${config.PORT || '3000'}`
    ];

    fs.writeFileSync(envPath, lines.join('\n'), 'utf-8');
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Get configuration path
ipcMain.handle('config:getPath', async () => {
  return envPath;
});

// Check if first run
ipcMain.handle('app:isFirstRun', async () => {
  return !fs.existsSync(envPath);
});

// Validate token
ipcMain.handle('token:validate', async (event, accessToken) => {
  try {
    const { default: validateToken } = await import('../lib/tokenValidator.js');
    const result = await validateToken(accessToken);
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Start OAuth server
ipcMain.handle('oauth:start', async (event, port = 3000) => {
  try {
    if (oauthServerProcess) {
      return { success: false, error: 'OAuth server is already running' };
    }

    // Load current configuration
    const configResult = await loadConfig();
    if (!configResult.success) {
      return { success: false, error: 'Failed to load configuration' };
    }

    // Import and start the OAuth server
    const { startOAuthServer } = await import('./oauth-server-electron.js');

    await startOAuthServer({
      clientId: configResult.config.TWITCH_CLIENT_ID,
      clientSecret: configResult.config.TWITCH_CLIENT_SECRET,
      redirectUri: configResult.config.REDIRECT_URI || `http://localhost:${port}/callback`,
      port: port,
      configPath: envPath
    });

    oauthServerProcess = { running: true }; // Mark as running

    return { success: true, port };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Stop OAuth server
ipcMain.handle('oauth:stop', async () => {
  await stopOAuthServer();
  return { success: true };
});

async function stopOAuthServer() {
  if (oauthServerProcess && oauthServerProcess.running) {
    try {
      const { stopOAuthServer: stopServer } = await import('./oauth-server-electron.js');
      await stopServer();
      oauthServerProcess = null;
    } catch (error) {
      console.error('Error stopping OAuth server:', error);
    }
  }
}

// Start EventSub monitoring
ipcMain.handle('eventsub:start', async () => {
  try {
    if (eventSubProcess) {
      return { success: false, error: 'EventSub is already running' };
    }

    // Load configuration
    const configResult = await loadConfig();
    if (!configResult.success || !configResult.config.TWITCH_ACCESS_TOKEN) {
      return { success: false, error: 'Configuration not found. Please complete setup first.' };
    }

    // Set environment variables from config
    const envVars = {
      ...process.env,
      TWITCH_CLIENT_ID: configResult.config.TWITCH_CLIENT_ID || '',
      TWITCH_CLIENT_SECRET: configResult.config.TWITCH_CLIENT_SECRET || '',
      TWITCH_ACCESS_TOKEN: configResult.config.TWITCH_ACCESS_TOKEN || '',
      TWITCH_BROADCASTER_ID: configResult.config.TWITCH_BROADCASTER_ID || '',
      REDIRECT_URI: configResult.config.REDIRECT_URI || '',
      PORT: configResult.config.PORT || ''
    };

    eventSubProcess = fork(
      path.join(__dirname, '../index.js'),
      [],
      {
        env: envVars,
        stdio: 'pipe'
      }
    );

    eventSubProcess.stdout.on('data', (data) => {
      if (mainWindow) {
        mainWindow.webContents.send('eventsub:log', {
          type: 'info',
          message: data.toString()
        });
      }
    });

    eventSubProcess.stderr.on('data', (data) => {
      if (mainWindow) {
        mainWindow.webContents.send('eventsub:log', {
          type: 'error',
          message: data.toString()
        });
      }
    });

    eventSubProcess.on('exit', (code) => {
      eventSubProcess = null;
      if (mainWindow) {
        mainWindow.webContents.send('eventsub:stopped', code);
      }
    });

    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Stop EventSub monitoring
ipcMain.handle('eventsub:stop', async () => {
  stopEventSub();
  return { success: true };
});

function stopEventSub() {
  if (eventSubProcess) {
    eventSubProcess.kill();
    eventSubProcess = null;
  }
}

// Get EventSub status
ipcMain.handle('eventsub:status', async () => {
  return { running: eventSubProcess !== null };
});

// Open external URL
ipcMain.handle('shell:openExternal', async (event, url) => {
  const { shell } = await import('electron');
  await shell.openExternal(url);
  return { success: true };
});

// Show open dialog
ipcMain.handle('dialog:showOpen', async (event, options) => {
  const result = await dialog.showOpenDialog(mainWindow, options);
  return result;
});

// Show save dialog
ipcMain.handle('dialog:showSave', async (event, options) => {
  const result = await dialog.showSaveDialog(mainWindow, options);
  return result;
});

// Get app version
ipcMain.handle('app:getVersion', async () => {
  return app.getVersion();
});

// Get app path
ipcMain.handle('app:getPath', async (event, name) => {
  return app.getPath(name);
});
